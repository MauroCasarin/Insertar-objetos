<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LayerMaster AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Babel para transpilar JSX/TSX en el navegador -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- 
      NOTA PARA DESARROLLO LOCAL: 
      Esta aplicación usa Módulos ES6. Debes servir este archivo desde un servidor web local
      (ej. usando la extensión "Live Server" en VS Code), no abrirlo directamente como un archivo (file://).
    -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "@google/genai": "https://esm.sh/@google/genai@0.14.0"
      }
    }
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; }
        /* Mejora para los sliders */
        input[type=range] { -webkit-appearance: none; background: transparent; width: 100%; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 99px; background: #818cf8; cursor: pointer; margin-top: -6px; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #334155; border-radius: 99px; }
        .fade-in { animation: fadeIn 0.3s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useEffect, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { GoogleGenAI } from "@google/genai";

        // ========================================================================================
        // COMPATIBILIDAD CON GITHUB PAGES Y GESTIÓN DE API KEY
        // ========================================================================================
        if (typeof process === 'undefined') {
          window.process = {
            env: {
              API_KEY: "AIzaSyBftQS8WXxOKIJvAfPYqw51znyw4FTBHvk" 
            }
          };
        }

        // ========================================================================================
        // LÓGICA DE IMAGEN
        // ========================================================================================
        const loadLayer = (file) => {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => {
              const img = new Image();
              img.onload = () => resolve(img);
              img.onerror = (err) => reject(err);
              img.src = event.target.result;
            };
            reader.onerror = (err) => reject(err);
            reader.readAsDataURL(file);
          });
        };

        const processTransparencyData = (img, removeWhite) => {
          if (!removeWhite || !img) return Promise.resolve(img);
          return new Promise((resolve) => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            if (!ctx) return resolve(img);

            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const threshold = 245; 

            for (let i = 0; i < data.length; i += 4) {
              const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
              if (brightness > threshold) {
                data[i + 3] = 0; // Hacer transparente
              }
            }
            ctx.putImageData(imageData, 0, 0);
            const newImg = new Image();
            newImg.onload = () => resolve(newImg);
            newImg.src = canvas.toDataURL();
          });
        };

        // ========================================================================================
        // SERVICIO DE IA
        // ========================================================================================
        const generateRealisticRender = async (imageBase64) => {
          if (!process.env.API_KEY) {
            alert("API Key no configurada. Por favor, edita el archivo index.html y añade tu clave API de Gemini para usar esta función.");
            throw new Error("API Key is missing.");
          }
          const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
          const data = imageBase64.replace(/^data:image\/\w+;base64,/, "");
          const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: { parts: [ { inlineData: { mimeType: 'image/png', data } }, { text: "ACT AS: Expert CGI Compositor. TASK: Create a photorealistic photo from this composite. 1. Fix Perspective & Scale: Realistically integrate the foreground object. 2. Fix Lighting: Relight the object to match the background source. Cast realistic shadows. 3. Blend: Match white balance, grain, and focus. The output must be only the final, ultra-realistic image." } ] }
          });
          const resultPart = response.candidates?.[0]?.content?.parts?.find(p => p.inlineData);
          if (resultPart) return `data:image/png;base64,${resultPart.inlineData.data}`;
          throw new Error("La IA no devolvió una imagen.");
        };

        // ========================================================================================
        // COMPONENTES REACT
        // ========================================================================================
        const FileInput = ({ type, onFileLoad, fileName }) => {
            const id = `file-input-${type}`;
            const isBg = type === 'background';
            const accentColor = isBg ? 'indigo' : 'pink';
            const icon = isBg ? 
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg> :
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"></path></svg>;

            const successIcon = <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7"></path></svg>;

            return (
                <div>
                    <label className="text-xs font-semibold text-slate-400 mb-1.5 block uppercase tracking-wide">{isBg ? '1. Fondo (Lugar)' : '2. Objeto (Frente)'}</label>
                    <label htmlFor={id} className={`flex items-center justify-center w-full p-3 border-2 rounded-xl transition-all cursor-pointer group hover:shadow-lg relative overflow-hidden ${fileName ? `border-solid border-green-500 bg-green-500/10` : `border-dashed border-slate-600 hover:border-${accentColor}-500 hover:bg-slate-700/50 bg-slate-800`}`}>
                        <span className={`text-sm flex items-center gap-2 z-10 truncate transition-colors ${fileName ? 'text-green-300' : `text-slate-300 text-${accentColor}-400`}`}>
                            {fileName ? successIcon : icon}
                            <span className="truncate">{fileName || `Subir ${isBg ? 'Fondo' : 'Objeto'}`}</span>
                        </span>
                        <input id={id} type="file" accept="image/*" className="hidden" onChange={onFileLoad} />
                    </label>
                </div>
            );
        };
        
        const ControlPanel = ({ onFileChange, transform, onTransformChange, onExport, onAiRender, isGenerating, images }) => {
            const updateTransform = (key, value) => {
              onTransformChange(prev => ({ ...prev, [key]: value }));
            };
            
            return (
                <aside className="w-full lg:w-80 bg-slate-800 p-6 flex flex-col gap-5 shadow-2xl z-20 h-auto lg:h-full overflow-y-auto border-r border-slate-700">
                    <div className="flex items-center gap-2 mb-1">
                        <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-indigo-500 to-purple-600 flex items-center justify-center shadow-lg ring-1 ring-white/10">
                            <svg className="w-5 h-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" /></svg>
                        </div>
                        <h1 className="text-2xl font-bold text-white tracking-tight">LayerMaster AI</h1>
                    </div>
                    <div className="space-y-4">
                        <FileInput type="background" onFileLoad={e => onFileChange('background', e.target.files[0])} fileName={images.background?.fileName} />
                        <FileInput type="foreground" onFileLoad={e => onFileChange('foreground', e.target.files[0])} fileName={images.foreground?.fileName} />
                    </div>
                    <hr className="border-slate-700/50" />
                    <div className={`space-y-5 transition-opacity duration-300 ${!images.foreground ? 'opacity-40 pointer-events-none' : ''}`}>
                        <h3 className="text-sm font-bold text-white uppercase tracking-wider">Ajustes Manuales</h3>
                        <div className="space-y-2">
                          <div className="flex justify-between items-center"><label className="text-xs text-slate-400">Tamaño</label><span className="text-xs font-mono bg-slate-900 px-1.5 py-0.5 rounded text-indigo-400">{transform.scale.toFixed(2)}x</span></div>
                          <input type="range" min="0.1" max="3" step="0.05" value={transform.scale} onChange={(e) => updateTransform('scale', parseFloat(e.target.value))} />
                        </div>
                        <div className="space-y-2">
                          <div className="flex justify-between items-center"><label className="text-xs text-slate-400">Rotación</label><span className="text-xs font-mono bg-slate-900 px-1.5 py-0.5 rounded text-indigo-400">{transform.rotation}°</span></div>
                          <input type="range" min="0" max="360" value={transform.rotation} onChange={(e) => updateTransform('rotation', parseInt(e.target.value))} />
                        </div>
                        <div className="space-y-2">
                          <div className="flex justify-between items-center"><label className="text-xs text-slate-400">Opacidad</label><span className="text-xs font-mono bg-slate-900 px-1.5 py-0.5 rounded text-indigo-400">{Math.round(transform.opacity * 100)}%</span></div>
                          <input type="range" min="0" max="1" step="0.01" value={transform.opacity} onChange={(e) => updateTransform('opacity', parseFloat(e.target.value))} />
                        </div>
                        <div className="flex items-center gap-3 bg-slate-700/20 p-3 rounded-lg border border-slate-700/50">
                            <input id="removeWhite" type="checkbox" checked={transform.removeWhite} onChange={(e) => updateTransform('removeWhite', e.target.checked)} className="w-4 h-4 text-indigo-600 rounded bg-slate-700 border-slate-600 cursor-pointer focus:ring-indigo-500" />
                            <label htmlFor="removeWhite" className="text-xs text-slate-300 cursor-pointer select-none font-medium">Quitar fondo blanco (Magic)</label>
                        </div>
                    </div>
                    <div className="mt-auto pt-4 space-y-3">
                        <button onClick={onAiRender} disabled={isGenerating || !images.background || !images.foreground} className="w-full py-3.5 px-4 text-white font-bold rounded-xl shadow-lg transition-all flex items-center justify-center gap-2 relative overflow-hidden disabled:grayscale disabled:opacity-50 disabled:cursor-not-allowed bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-500 hover:to-indigo-500 border border-white/10">
                            {isGenerating ? <><svg className="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path></svg><span>Procesando...</span></> : <><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z" /></svg><span>Render Realista (IA)</span></>}
                        </button>
                        <button onClick={onExport} disabled={!images.background} className="w-full py-2.5 px-4 bg-slate-700/50 hover:bg-slate-700 text-slate-300 hover:text-white font-medium rounded-xl transition-all flex items-center justify-center gap-2 text-xs border border-slate-600 hover:border-slate-500 disabled:opacity-50 disabled:cursor-not-allowed">
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
                            Descargar Borrador
                        </button>
                    </div>
                </aside>
            );
        };
        
        // ========================================================================================
        // COMPONENTE PRINCIPAL
        // ========================================================================================
        function App() {
          const canvasRef = useRef(null);
          const [images, setImages] = useState({ background: null, foreground: null, processedForeground: null });
          const [transform, setTransform] = useState({ x: 0, y: 0, scale: 0.5, rotation: 0, opacity: 1, removeWhite: false });
          const [isDragging, setIsDragging] = useState(false);
          const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
          const [isGenerating, setIsGenerating] = useState(false);
          const [generatedImage, setGeneratedImage] = useState(null);

          const updateCanvas = useCallback(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (images.background) {
              ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height);
            } else {
              ctx.fillStyle = '#1e293b'; ctx.fillRect(0, 0, canvas.width, canvas.height);
              ctx.font = 'bold 16px Inter, sans-serif'; ctx.fillStyle = '#64748b'; ctx.textAlign = 'center';
              ctx.fillText('Carga una imagen de Fondo para comenzar', canvas.width / 2, canvas.height / 2);
            }
            const fgToDraw = images.processedForeground || images.foreground;
            if (fgToDraw) {
              ctx.save();
              ctx.translate(canvas.width / 2 + transform.x, canvas.height / 2 + transform.y);
              ctx.rotate((transform.rotation * Math.PI) / 180);
              ctx.scale(transform.scale, transform.scale);
              ctx.globalAlpha = transform.opacity;
              ctx.drawImage(fgToDraw, -fgToDraw.width / 2, -fgToDraw.height / 2);
              ctx.restore();
            }
          }, [images, transform]);

          useEffect(() => {
            const animationFrame = requestAnimationFrame(updateCanvas);
            return () => cancelAnimationFrame(animationFrame);
          }, [updateCanvas]);

          useEffect(() => {
            const process = async () => {
              const processed = await processTransparencyData(images.foreground, transform.removeWhite);
              setImages(prev => ({ ...prev, processedForeground: processed }));
            };
            if (images.foreground) process();
          }, [images.foreground, transform.removeWhite]);
          
          const handleFileChange = async (type, file) => {
            if(!file) return;
            try {
                const img = await loadLayer(file);
                img.fileName = file.name; // Store filename for UI
                setImages(prev => ({ ...prev, [type]: img }));
                if(type === 'background' && canvasRef.current) {
                    const aspect = img.width / img.height;
                    const container = canvasRef.current.parentElement.parentElement;
                    const containerWidth = container.clientWidth - 40; // p-4
                    const containerHeight = container.clientHeight - 40;
                    
                    let newWidth = containerWidth;
                    let newHeight = newWidth / aspect;

                    if (newHeight > containerHeight) {
                        newHeight = containerHeight;
                        newWidth = newHeight * aspect;
                    }
                    
                    canvasRef.current.width = newWidth;
                    canvasRef.current.height = newHeight;
                }
                if (type === 'foreground') {
                    setTransform(prev => ({ ...prev, x: 0, y: 0, scale: 0.5, rotation: 0 }));
                }
            } catch (error) {
                console.error("Error loading image:", error);
                alert("No se pudo cargar la imagen. Intenta con otro archivo.");
            }
        };

          const handleMouseDown = (e) => {
            if (!images.foreground) return;
            e.preventDefault();
            setIsDragging(true);
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            setDragStart({ x: clientX - transform.x, y: clientY - transform.y });
          };
          const handleMouseMove = (e) => {
            if (!isDragging) return;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            setTransform(prev => ({ ...prev, x: clientX - dragStart.x, y: clientY - dragStart.y }));
          };
          const handleMouseUp = () => setIsDragging(false);

          const handleExport = () => {
            if (!canvasRef.current) return;
            const link = document.createElement('a');
            link.download = 'composicion.png';
            link.href = canvasRef.current.toDataURL('image/png');
            link.click();
          };

          const handleAiRender = async () => {
            if (!canvasRef.current) return;
            setIsGenerating(true);
            try {
              const result = await generateRealisticRender(canvasRef.current.toDataURL('image/png'));
              setGeneratedImage(result);
            } catch (error) {
              console.error("AI Render failed:", error);
            } finally {
              setIsGenerating(false);
            }
          };

          return (
            <div className="flex flex-col lg:flex-row h-screen bg-slate-900 text-slate-200 overflow-hidden">
              <ControlPanel 
                onFileChange={handleFileChange}
                transform={transform}
                onTransformChange={setTransform}
                onExport={handleExport}
                onAiRender={handleAiRender}
                isGenerating={isGenerating}
                images={images} />
              <main className="flex-1 relative flex items-center justify-center bg-black/50 p-4" onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onTouchMove={handleMouseMove} onTouchEnd={handleMouseUp}>
                <div className="relative shadow-2xl border border-slate-700 rounded-lg overflow-hidden bg-slate-900 shadow-purple-500/10">
                  <canvas ref={canvasRef} width={800} height={500} className={`block object-contain max-w-full max-h-full`} onMouseDown={handleMouseDown} onTouchStart={handleMouseDown} style={{cursor: isDragging ? 'grabbing' : images.foreground ? 'grab' : 'default'}}/>
                </div>
              </main>
              {generatedImage && (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 fade-in">
                  <div className="bg-slate-800 rounded-xl max-w-5xl w-full max-h-[90vh] flex flex-col shadow-2xl overflow-hidden border border-slate-700">
                    <div className="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-900/50">
                        <h2 className="text-xl font-bold text-white flex items-center gap-2"><span className="text-purple-400">✨</span> Resultado IA</h2>
                        <button onClick={() => setGeneratedImage(null)} className="p-2 rounded-full text-slate-400 hover:text-white hover:bg-slate-700 transition-colors"><svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg></button>
                    </div>
                    <div className="flex-1 overflow-auto bg-slate-950 flex items-center justify-center p-6"><img src={generatedImage} alt="AI Generated Render" className="max-w-full max-h-full rounded-lg shadow-2xl" /></div>
                    <div className="p-4 bg-slate-900 border-t border-slate-700 flex justify-end gap-3">
                        <button onClick={() => setGeneratedImage(null)} className="px-5 py-2.5 text-slate-300 hover:text-white font-medium rounded-lg hover:bg-slate-700 transition-colors">Cerrar</button>
                        <a href={generatedImage} download="render-ia.png" className="px-6 py-2.5 bg-gradient-to-r from-purple-600 to-indigo-600 text-white font-bold rounded-lg shadow-lg flex items-center gap-2 transition-all hover:brightness-110 transform hover:-translate-y-0.5"><svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>Descargar</a>
                    </div>
                  </div>
                </div>
              )}
            </div>
          );
        }

        // ========================================================================================
        // PUNTO DE ENTRADA
        // ========================================================================================
        const container = document.getElementById('root');
        const root = createRoot(container);
        root.render(<App />);

    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>